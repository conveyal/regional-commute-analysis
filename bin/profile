#!/usr/bin/env node

var args = require('minimist')(process.argv.slice(2), {
  string: [ 'start', 'end' ]
});

var Batch = require('batch');
var debug = require('debug')('regional-commute-analysis:profile');
var resolve = require('path').resolve;
var factors = args.factors
  ? require(resolve(args.factors))
  : null;

var fs = require('fs');
var journeys = require(resolve(args._[0]));
var Profiler = require('otp-profiler');
var ProfileScore = require('otp-profile-score');
var Progress = require('progress');

var batch = new Batch;
var profiler = new Profiler({
  host: args.host
});
var scorer = new ProfileScore(factors);
var writer = fs.createWriteStream(args._[1], { encoding: 'utf8' });

batch.concurrency(2);

debug('profiling ' + journeys.length + ' journeys');

var errorWriter = fs.createWriteStream(args.errors, { encoding: 'utf8' });
var previous = false;
var progress = new Progress(':bar', { total: journeys.length });

journeys.forEach(function(journey) {
  batch.push(function(done) {
    profiler.profile({
      from: {
        lon: journey[0][0],
        lat: journey[0][1]
      },
      to: {
        lon: journey[1][0],
        lat: journey[1][1]
      },
      orderBy: 'AVG',
      modes: args.modes,
      startTime: args.start,
      endTime: args.end,
      limit: args.limit || 3,
    }, function(err, results) {
      if (err) {
        errorWriter.write(JSON.stringify({
          error: err,
          journey: journey
        }, 'utf8', function() {
          done();
        }));
      } else if (!results || !results.options || results.options.length < 1) {
        errorWriter.write(JSON.stringify({
          error: 'No results returned',
          journey: journey
        }), 'utf8', function() {
          done();
        });
      } else {
        var options = args.score
          ? scorer.processOptions(results.options)
          : results.options;

        options = filterOptions(options);

        var s = JSON.stringify({
          journey: journey,
          options: options
        });

        if (previous) s = ',' + s;

        previous = true;
        writer.write(s, 'utf8', function() {
          done();
        });
      }
    });
  });
});

batch.on('progress', function() {
  progress.tick();
});

writer.write('[', 'utf8', function() {
  batch.end(function(err, results) {
    if (err) console.error(err);

    debug('finished with ' + errors.length + ' errors');
    fs.writeFileSync(args.errors, JSON.stringify(errors, null, '\t'), { encoding: 'utf8' });

    writer.end(']', 'utf8', function() {
      process.exit();
    });
  });
});

function filterOptions(options) {
  // Only keep the walkstep distance
  for (var i = 0; i < options.length; i++) {
    if (options[i].walkSteps) {
      options[i].walkSteps = options[i].walkSteps.map(function(step) {
        return {
          distance: step.distance
        };
      });
    }
  }

  return options;
}
