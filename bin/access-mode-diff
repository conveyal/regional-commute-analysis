#!/usr/bin/env node

var args = require('minimist')(process.argv.slice(2), {
  string: [ 'start', 'end' ]
});

var Batch = require('batch');
var resolve = require('path').resolve;

var fs = require('fs');
var Profiler = require('otp-profiler');
var Progress = require('progress');
var Scorer = require('otp-profile-score');

var batch = new Batch();
var profiler = new Profiler({
  host: args.host
});
var scorer = new Scorer();

var writeHeader = !fs.existsSync(args._[1]);
var fd = fs.openSync(args._[1], 'a');
var errorFd = fs.openSync('data/errors.json', 'w');

if (writeHeader) {
  var headingBuf = new Buffer('flng,flat,tlng,tlat,trips,distance,dbike,dwalk,tbike,twalk', 'utf8');
  fs.writeSync(fd, headingBuf, 0, headingBuf.length);
}

var stats = {
  errors: 0,
  noResults: 0,
  noRoute: 0,
  noWalk: 0
};

batch.concurrency(args.concurrency);

var journeys = fs.readFileSync(resolve(args._[0]), { encoding: 'utf8' }).split('\n').slice(1);

console.log('profiling ' + journeys.length + ' journeys');

var previous = false;
var progress = new Progress(':bar', { total: journeys.length });

journeys.forEach(function(journey) {
  batch.push(function(done) {
    profileJourney(journey.split(','), done);
  });
});

batch.on('progress', function() { progress.tick(); });

batch.end(function(err, results) {
  if (err) console.error(err);

  fs.closeSync(fd);
  fs.closeSync(errorFd);

  console.log('stats:');
  console.log(JSON.stringify(stats, null, '\t'));
  process.exit();
});

function profileJourney(journey, complete) {
  profile(journey, function(err, results) {
    if (err) {
      stats.errors++;
      return saveFailedOtpQuery(err, complete);
    } else if (!results || !results.options) {
      stats.noResults++;
      return complete();
    }

    var options = scorer.processOptions(results.options);

    var dwalk = getOpt(options, 'WALK', true);
    var dbike = getOpt(options, 'BICYCLE', true);
    var twalk = getOpt(options, 'WALK', false);
    var tbike = getOpt(options, 'BICYCLE', false);

    if (!dbike && !tbike) {
      stats.noRoute++;
      return complete();
    }

    if (!dwalk && !twalk) stats.noWalk++;

    var dwalkTime = dwalk ? dwalk.stats.avg : 0;
    var dwalkDistance = dwalk ? dwalk.walkDistance : 0;

    var dbikeTime = dbike ? dbike.stats.avg : 0;
    var dbikeDistance = dbike ? dbike.bikeDistance : 0;

    var twalkTime = twalk ? twalk.stats.avg : 0;
    var twalkDistance = twalk ? twalk.walkDistance : 0;

    var tbikeTime = tbike ? tbike.stats.avg : 0;
    var tbikeDistance = tbike ? tbike.bikeDistance : 0;

    var csv = [
      journey[0], // from lng
      journey[1], // from lat
      journey[2], // to lng
      journey[3], // to lat
      journey[4], // trips (used as a multiplier on the client)
      journey[5], // distance (haversine)
      dbikeTime, // direct bike time
      dbikeDistance, // direct bike distance
      dwalkTime, // direct walk time
      dwalkDistance, // direct walk distance
      tbikeTime, // transit
      tbikeDistance, // bike to transit distance
      twalkTime, // walk to transit total trip time
      twalkDistance // total walking distance
    ];
    var buffer = new Buffer('\n' + csv.join(','), 'utf8');

    previous = true;
    fs.write(fd, buffer, 0, buffer.length, null, complete);
  });
}

function profile(journey, done) {
  profiler.profile({
    from: {
      lon: journey[0],
      lat: journey[1]
    },
    to: {
      lon: journey[2],
      lat: journey[3]
    },
    accessModes: 'WALK,BICYCLE',
    directModes: 'WALK,BICYCLE',
    egressModes: 'WALK',
    transitModes: 'BUS,TRAINISH',
    startTime: '06:00',
    endTime: '09:00',
    limit: 1 // just get the fastest
  }, done);
}

function getOpt(options, mode, direct) {
  for (var i = 0; i < options.length; i++) {
    var option = options[i];
    if (option.access[0].mode === mode) {
      if (direct) {
        if (!option.transit || option.transit.length === 0) {
          return option;
        }
      } else {
        if (option.transit && option.transit.length > 0) {
          return option;
        }
      }
    }
  }
}

function saveFailedOtpQuery(error, done) {
  var buffer = new Buffer(',\n' + JSON.stringify(error, null, '\t'), 'utf8');
  fs.write(errorFd, buffer, 0, buffer.length, null, done);
}
