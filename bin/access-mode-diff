#!/usr/bin/env node

var args = require('minimist')(process.argv.slice(2));

var Batch = require('batch');
var resolve = require('path').resolve;

var fs = require('fs');
var ms = require('ms');
var Profiler = require('otp-profiler');
var Progress = require('progress');
var Scorer = require('otp-profile-score');

var batch = new Batch();
var profiler = new Profiler({
  host: args.host
});
var scorer = new Scorer();
var first = true;

var profilesFile = resolve(args._[1]);
var profiles = [];
if (fs.existsSync(profilesFile))
  profiles = require(profilesFile);

profiles = profiles.filter(function(p) {
  return p !== null && p !== undefined;
});

var odpairs = fs.readFileSync(resolve(args._[0]), { encoding: 'utf8' }).split('\n').slice(1);

var stats = {
  errors: 0,
  noResults: 0,
  notUpdated: 0,
  success: 0
};

var message = '';
var last100speeds = [];
var last100total = 0;
var last100avg = 0;
var start = new Date();
var progress = new Progress('[:current/:total] :timeleft left :average avg :errors errors > :message', {
  total: odpairs.length,
  width: 20
});

batch.concurrency(args.concurrency);

odpairs.forEach(function(journey) {
  batch.push(function(done) {
    profileJourney(journey.split(','), done);
  });
});

batch.on('progress', function(e) {
  var elapsed = new Date() - start;
  var timeleft = (progress.percent == 100)
    ? 0
    : elapsed * (progress.total / progress.curr - 1);

  if (last100speeds.length >= 100)
    last100total -= last100speeds.shift();

  var speed = e.end - e.start;
  last100total += speed;
  last100speeds.push(speed);
  last100avg = last100total / last100speeds.length;

  progress.tick({
    average: ms(last100avg),
    errors: stats.errors,
    last: ms(speed),
    message: message,
    timeleft: ms(timeleft)
  });
});

batch.end(function(err, results) {
  if (err) console.error(err);

  fs.writeFileSync(profilesFile, JSON.stringify(profiles, null, '\t'));

  console.log('stats:');
  console.log(JSON.stringify(stats, null, '\t'));
  process.exit();
});

function profileJourney(journey, complete) {
  var profileStart = new Date();

  for (var i = 0; i < profiles.length; i++) {
    var p = profiles[i];
    if (lleql([ journey[0], journey[1] ], p.from) && lleql([ journey[2], journey[3] ], p.to)) {
      if (args.force || !p.success) {
        profiles.splice(i, 1);
        break;
      } else {
        stats.notUpdated++;
        return complete();
      }
    }
  }

  profile(journey, function(err, results) {
    if (err) {
      stats.errors++;
      results = err;
      message = err.message || JSON.stringify(err);
    } else if (!results || !results.options) {
      stats.noResults++;
      results = [];
      message = 'No results found.';
    } else {
      results = scorer.processOptions(results.options);
      results.forEach(function(option) {
        option.access.forEach(function(access) {
          delete access.geometry;
          delete access.walkSteps;
        });

        if (option.egress) option.egress.forEach(function(egress) {
          delete egress.geometry;
          delete egress.walkSteps;
        });

        if (option.transit) option.transit.forEach(function(transit) {
          delete transit.segmentPatterns;
        });

        delete option.fares;
        delete option.summary;
      });

      stats.success++;
      message = results.length + ' results found.';
    }

    profiles.push({
      responseTime: new Date() - profileStart,
      success: !err,
      from: [ parseFloat(journey[0]), parseFloat(journey[1]) ],
      to: [ parseFloat(journey[2]), parseFloat(journey[3]) ],
      trips: parseInt(journey[4]),
      results: results
    });

    complete();
  });
}

function profile(journey, done) {
  profiler.profile({
    from: {
      lon: journey[0],
      lat: journey[1]
    },
    to: {
      lon: journey[2],
      lat: journey[3]
    },
    accessModes: 'WALK,BICYCLE',
    directModes: 'WALK,BICYCLE',
    egressModes: 'WALK',
    transitModes: 'BUS,TRAINISH',
    startTime: '06:00',
    endTime: '09:00',
    limit: 1 // just get the fastest
  }, done);
}

function lleql(l1, l2) {
  if (!l1 || !l2 || !Array.isArray(l2)) return false;
  return parseFloat(l1[0]) == parseFloat(l2[0]) && parseFloat(l1[1]) == parseFloat(l2[1]);
}
