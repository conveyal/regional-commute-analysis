<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="//api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/dc/1.6.0/dc.css">
    <style>
      body {
        padding-bottom: 400px;
      }

      .dc-table-group {
        display: none;
      }

      #map {
        height: 500px;
        width: 100%;
        border-bottom: 4px solid #ddd;
        margin-bottom: 10px;
      }

      #modes {
        margin-bottom: 10px;
      }

      #modes label {
        margin-right: 10px;
      }

      .color-scale-block {
        display: inline-block;
        padding: 0 5px;
      }
    </style>
  </head>
  <body>
    <div id="viz" style="display:none;">
      <div id="map"></div>
      <div class="container">
        <div class="row" style="text-align: center;">
          <div id="data-count" class="col-sm-4">
            <strong class="filter-count"></strong> out of <strong class="total-count"></strong>
          </div>
          <div class="col-sm-4">
            <span id="min-time"></span>
            <span id="color-scale"></span>
            <span id="max-time"></span>
          </div>
          <div id="stats" class="col-sm-4">
            <strong class="time-saved"></strong> total min saved
          </div>
        </div>
        <br>
        <div class="row">
          <div id="distance-chart" class="col-sm-4">
            <strong>Distance (mi)</strong>
            <span class="filter"></span>
            <a class="reset" href="javascript:charts.distance.filterAll();dc.redrawAll();" style="display:none;">reset</a>
            <div class="clearfix"></div>
          </div>
          <div id="impact-chart" class="col-sm-4">
            <strong>Impact (Walk time - Bike time)</strong>
            <a class="reset" href="javascript:charts.impact.filterAll();dc.redrawAll();" style="display:none;">reset</a>
            <div class="clearfix"></div>
          </div>
          <div id="percent-chart" class="col-sm-4">
            <strong>Bike Access % of Trip</strong>
            <a class="reset" href="javascript:charts.percent.filterAll();dc.redrawAll();" style="display:none;">reset</a>
            <div class="clearfix"></div>
          </div>
        </div>
        <div class="row">
          <div class="col-sm-6">
            <form class="form">
              <div class="checkbox">
                <label>
                  <input id="works-in-bounds" type="checkbox" checked> Works in Arlington
                </label>
              </div>
              <div class="checkbox">
                <label>
                  <input id="works-out-bounds" type="checkbox" checked> Works outside Arlington
                </label>
              </div>
              <div class="radio">
                <label>
                  <input type="radio" name="journeyType" id="bike-and-walk" value="bikeAndWalk" checked>
                  Bike-to-transit vs walk-to-transit
                </label>
              </div>
              <div class="radio">
                <label>
                  <input type="radio" name="journeyType" id="bike-only" value="bikeOnly">
                  Bike-to-transit but no walk-to-transit
                </label>
              </div>
              <div class="radio">
                <label>
                  <input type="radio" name="journeyType" id="car-only" value="carOnly">
                  Direct Bike or Car only
                </label>
              </div>
            </form>
          </div>
          <div class="col-sm-6">
            <h3>Commute Profiles</h3>
            <p>The data shown is from journey profiles generated by OpenTripPlanner's Profile Routing engine. The journeys are taken from the 2011 census commutes for the DC/VA/MD region which contains home/work locations by census block.</p>
            <p>Only commuters living in Arlington, or commuting to Arlington were used due to large size of the data set of the region.<p>
            <p>The profiles created used a few assumptions:</p>
            <ul>
              <li>A commute time between 6am and 9am</li>
              <li>Maximum walk time of 15 minutes</li>
              <li>Walk speed of ~3.2mph</li>
              <li>Bike speed of ~9.2mph</li>
            </ul>
            <p>The transit network comes from all availalbe GTFS feeds in the area. The road network to derive the biking options comes from OpenStreetMap.</p>
          </div>
        </div>
      </div>
    </div>

    <script src="//cdnjs.cloudflare.com/ajax/libs/spin.js/2.0.1/spin.min.js"></script>
    <script src="//api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-pip/v0.0.2/leaflet-pip.js'></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.13/d3.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/crossfilter/1.3.7/crossfilter.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/dc/1.6.0/dc.js"></script>
    <script src="http://d3js.org/colorbrewer.v1.min.js"></script>
    <script src="d3.hexbin.v0.min.js"></script>
    <script src="hexbin.js"></script>
    <script>
      // Spinner
      var spinner = new Spinner().spin(document.body);

      // constants
      var height = 150,
        width = 400,
        margin = {
          top: 10,
          right: 10,
          bottom: 20,
          left: 40
        };

      var colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'];

      // globals
      var blocks, currentDimension, data, dimensions = {}, geoBounds,
        _id, json, originalJSON, map, options;

      // Checkboxes
      var $destinationInBounds = document.getElementById('works-in-bounds');
      var $destinationOutBounds = document.getElementById('works-out-bounds');

      // Radio
      var $bikeAndWalk = document.getElementById('bike-and-walk');
      var $bikeOnly = document.getElementById('bike-only');
      var $carOnly = document.getElementById('car-only');

      // Max time
      var $colorscale = document.getElementById('color-scale');
      var $maxtime = document.getElementById('max-time');
      var $mintime = document.getElementById('min-time');

      // Expose charts
      var charts = window.charts = {};

      // Load Bounds
      d3.json('data/bounds.geo.json', processGeoJson);

      function processGeoJson(err, j) {
        if (err) console.error(err);
        geoBounds = j;

        // Load json
        d3.csv('data/access-mode-diff.csv', function(d) {
          return {
            coords: [
              [ +d.flng, +d.flat ],
              [ +d.tlng, +d.tlat ]
            ],
            distance: haversine(+d.flat, +d.flng, +d.tlat, +d.tlng, true),
            trips: +d.trips,
            dbike: +d.dbike,
            dwalk: +d.dwalk,
            tbike: +d.tbike,
            tbikea: +d.tbikea,
            twalk: +d.twalk,
            twalka: +d.twalka,
            impact: 0,
            modes: 1 // All
          };
        }, processCsv);
      }

      function processCsv(err, j) {
        if (err) console.error(err);
        json = j;

        // Duplicate records based on # of trips
        var duplicates = [];
        json.forEach(function(r) {
          if (r.twalk === -1 && r.tbike === -1) {
            r.modes = 3; // no bike or walk
          } else if (r.twalk === -1) {
            r.impact = r.tbike;
            r.modes = 2; // no walk
          } else if (r.twalk > r.tbike) {
            r.impact = (r.twalk - r.tbike);
          }

          for (var i = 1; i < r.trips; i++) {
            var c = clone(r);
            delete c.trips;
            duplicates.push(clone(r));
          }
          delete r.trips;
        });
        json = json.concat(duplicates);

        // Filter out the outliers
        json = json.filter(function(d) {
          return d.modes > 1 || d.impact < 20;
        });

        // Show viz & stop spinner
        document.getElementById('viz').style.display = 'block';

        // After displaying, setup the map
        map = L.mapbox.map('map', 'conveyal.gepida3i', {
          touchZoom: false,
          scrollWheelZoom: false
        }).setView([38.8399874, -77.0911667], 11);

        // Add bounds
        geoBounds = L.geoJson(geoBounds, {
           style: {
             fillOpacity: 0
           }
        }).addTo(map);

        // Generate Hexbins
        map.on('viewreset', function() {
          generateHexbins(map, dimensions);
        });

        // Crossfilterize
        processJson(json, map);

        // Show extends
        d3.json('data/outerbounds.geo.json', function(err, json) {
          L.geoJson(json, {
            style: {
              fillOpacity: 0
            }
          }).addTo(map)
        });
      }

      function processJson(json, map) {
        // Dispose of all dimensions
        for (var d in dimensions) dimensions[d].dispose();

        // Remove all current data
        if (options) options.remove();

        // Create the crossfilter instance
        options = crossfilter(json);

        // Create the dimensions
        dimensions = getDimensions(options);
        currentDimension = dimensions.distance;

        charts.distance = dc.lineChart('#distance-chart')
          .height(height)
          .width(width)
          .margins(margin)
          .x(d3.scale.linear().domain([0, 40]))
          .elasticY(true)
          .round(Math.round)
          .dimension(dimensions.distance)
          .group(dimensions.distance.group(function(d) {
            return Math.round(d);
          }));

        charts.impact = dc.barChart('#impact-chart')
          .height(height)
          .width(width)
          .margins(margin)
          .round(Math.round)
          .elasticY(true)
          .elasticX(true)
          .x(d3.scale.linear().domain([0, 20]))
          .dimension(dimensions.impact)
          .group(dimensions.impact.group(function(d) {
            return Math.round(d);
          }));

        charts.percent = dc.barChart('#percent-chart')
          .height(height)
          .width(width)
          .margins(margin)
          .round(Math.round)
          .elasticY(true)
          .elasticX(true)
          .x(d3.scale.linear().domain([0, 100]))
          .dimension(dimensions.percent)
          .group(dimensions.percent.group(function(d) {
            return Math.round(d);
          }));

        charts.count = dc.dataCount('#data-count')
          .dimension(options)
          .group(options.groupAll());

        dimensions.modes.filter(function(d) {
          return d === 1;
        });

        dc.renderAll();

        charts.distance.on('filtered', function() {
          currentDimension = dimensions.distance;
        });
        charts.impact.on('filtered', function() {
          currentDimension = dimensions.impact;
        });

        // Attach to dc.js renderLet
        charts.distance.renderlet(function(c) {
          dc.events.trigger(function() {
            // Rendering allll
            console.log('DC Events triggered');

            // Redraw the hexbins
            generateHexbins(map);

            // Show stats
            showStats(currentDimension.top(Infinity));

            // Stop spinner
            spinner.stop();
          });
        });

        $destinationInBounds.onchange = function() {
          filterDestinations($destinationInBounds.checked, $destinationOutBounds.checked, dimensions.destination, geoBounds);
        };

        $destinationOutBounds.onchange = function() {
          filterDestinations($destinationInBounds.checked, $destinationOutBounds.checked, dimensions.destination, geoBounds);
        };

        $bikeAndWalk.onchange = function() {
          dc.filterAll();
          dimensions.modes.filter(function(d) {
            return d === 1;
          });
          dc.renderAll();
        };

        $bikeOnly.onchange = function() {
          dc.filterAll();
          dimensions.modes.filter(function(d) {
            return d === 2;
          });
          dc.renderAll();
        };

        $carOnly.onchange = function() {
          dc.filterAll();
          dimensions.modes.filter(function(d) {
            return d === 3;
          });
          dc.renderAll();
        };
      }

      function showStats(rows) {
        var totalTimeSavings = rows.reduce(function(m, r) {
          return m + r.impact;
        }, 0);

        var el = document.querySelector('.time-saved');
        el.textContent = Math.round(totalTimeSavings);
      }

      function getDimensions(o) {
        return {
          distance: o.dimension(function(d) {
            return d.distance;
          }),
          impact: o.dimension(function(d) {
            return d.impact;
          }),
          destination: o.dimension(function(d) {
            return d.coords[1];
          }),
          modes: o.dimension(function(d) {
            return d.modes;
          }),
          percent: o.dimension(function(d) {
            if (d.tbike === -1) return 0;
            return (d.tbikea / d.tbike) * 100;
          })
        };
      }

      var _polygons = [];
      var _polylines = [];

      function generateHexbins(map) {
        _polylines.forEach(map.removeLayer.bind(map));
        _polygons.forEach(map.removeLayer.bind(map));

        var bounds = map.getBounds();
        var $map = document.getElementById('map');
        var rmax = (bounds.getNorth() - bounds.getSouth()) / 45;

        // Allllll
        var data = currentDimension.top(Infinity);

        // Generate hexbins
        var origins = data.map(function(d) {
          var j = d.coords[0];
          j.impact = d.impact;
          j.destination = d.coords[1];
          return j;
        });

        var cscale = null;
        var hexbins = hexbin(origins, {
          caccessor: function(b) {
            return b.impact;
          },
          cscale: function(bs) {
            var min = Infinity;
            var max = -Infinity;
            bs.forEach(function(b) {
              b.impact = b.reduce(function(v, j) {
                return v + j.impact;
              }, 0);
              b.impact = b.impact / b.length;
              if (b.impact < min) min = b.impact;
              if (b.impact > max) max = b.impact;
            });

            $maxtime.textContent = ' min';
            $colorscale.innerHTML = null;

            var impacts = bs.map(function(d) { return d.impact; });
            impacts.sort(d3.ascending);

            var middle = d3.quantile(impacts, 0.5);
            cscale = d3.scale.linear()
              .domain([ min, middle, max ])
              .range(colorbrewer.Spectral[3]);

            var scales = '';

            for (var i = 0; i <= 6; i++) {
              var q = d3.quantile(impacts, i / 6);
              scales += '<span class="color-scale-block" style="background-color:' + cscale(q) + ';">' + q.toFixed(1) + '</span>';
            }

            $colorscale.innerHTML = scales;

            return cscale;

          },
          height: $map.clientHeight,
          rmax: rmax,
          width: $map.clientWidth
        });

        _polygons = hexbins.map(function(d) {
          var center = [ d.center[1], d.center[0] ];
          return L.polygon(d.coords, {
            stroke: true,
            weight: 1,
            color: '#e5e5e5',
            fill: true,
            fillOpacity: 0.75,
            fillColor: d.color
          }).addTo(map).on('click', function() {
            _polylines.forEach(map.removeLayer.bind(map));
            _polylines = d.bin.map(function(bin) {
              var destination = bin.destination;
              return L.polyline([ center, [ destination[1], destination[0] ] ], {
                color: cscale(bin.impact),
                weight: 3
              }).addTo(map);
            });
          });
        });
      }

      function filterDestinations(inBound, outBound, dimension, bounds) {
        if (inBound && outBound) {
          dimension.filterAll();
        } else if (inBound) {
          dimension.filter(function(c) {
            return pip(c, bounds);
          });
        } else if (outBound) {
          dimension.filter(function(c) {
            return !pip(c, bounds);
          });
        } else {
          dimension.filter(function(c) {
            return false;
          });
        }

        dc.renderAll();
      }

      function pip(ll, bounds) {
        var layer = leafletPip.pointInLayer(ll, bounds, true);
        if (layer.length) return true;
        else return false;
      }

      function clone(obj) {
        if (obj === null || typeof(obj) != 'object')
          return obj;

        var temp = obj.constructor();
        for (var key in obj) temp[key] = clone(obj[key]);
        return temp;
      }

      /**
       * Get the haversine distance between two points
       *
       * @param {Number} starting latitude
       * @param {Number} starting longitude
       * @param {Number} ending latitude
       * @param {Number} ending longitude
       * @param {Boolean} return the distance in miles instead of kilometers
       * @returns {Number} distance between the points
       */

      function haversine(lat1, lon1, lat2, lon2, miles) {
        var R = miles ? 3960 : 6371;

        var dLat = rad(lat2 - lat1);
        var dLon = rad(lon2 - lon1);

        lat1 = rad(lat1);
        lat2 = rad(lat2);

        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
      };

      /**
       * Convert a lat/lon point to radians
       *
       * @param {Number} n
       * @returns {Number} r
       */

      function rad(n) {
        return n * Math.PI / 180;
      }
    </script>
  </body>
</html>