<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="//api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/dc/1.6.0/dc.css">
    <style>
      body {
        padding-bottom: 400px;
      }

      .dc-table-group {
        display: none;
      }

      #map {
        height: 500px;
        width: 100%;
        border-bottom: 4px solid #ddd;
      }

      #modes {
        margin-bottom: 10px;
      }

      #modes label {
        margin-right: 10px;
      }

      .color-scale-block {
        display: inline-block;
        padding: 0 5px;
      }

      .row {
        margin-top: 15px;
        margin-bottom: 15px;
      }
    </style>
  </head>
  <body>
    <div id="viz" style="display:none;">
      <div id="map"></div>
      <div class="container">
        <div class="row" style="text-align: center;">
          <div class="col-sm-12">
            <button class="btn btn-primary active" id="bike-and-walk">Bike-to vs walk-to transit commutes</button>
            <button class="btn btn-success" id="bike-only">Commutes made possible by bike-to-transit</button>
            <button class="btn btn-warning" id="car-only">Commutes without transit options</button>
          </div>
        </div>
        <hr>
        <div class="row" style="text-align: center;">
          <div id="data-count" class="col-sm-4">
            <strong class="filter-count"></strong> out of <strong class="total-count"></strong>
          </div>
          <div class="col-sm-4">
            <span id="color-scale-label">Impact</span> <span id="color-scale"></span> min
          </div>
          <div class="col-sm-4">
            <form class="form-inline">
              <div class="checkbox">
                <label>
                  <input id="show-bounds" type="checkbox" checked> Show bounds
                </label>
              </div>
            </form>
          </div>
        </div>
        <br>
        <div class="row">
          <div id="distance-chart" class="col-sm-4">
            <strong>Distance (mi)</strong>
            <span class="filter"></span>
            <a class="reset" href="javascript:charts.distance.filterAll();dc.redrawAll();" style="display:none;">reset</a>
            <div class="clearfix"></div>
          </div>
          <div id="impact-chart" class="col-sm-4">
            <strong id="impact-chart-label">Impact (Walk time - Bike time)</strong>
            <a class="reset" href="javascript:charts.impact.filterAll();dc.redrawAll();" style="display:none;">reset</a>
            <div class="clearfix"></div>
          </div>
          <div id="percent-chart" class="col-sm-4">
            <strong>Bike Access % of Trip</strong>
            <a class="reset" href="javascript:charts.percent.filterAll();dc.redrawAll();" style="display:none;">reset</a>
            <div class="clearfix"></div>
          </div>
        </div>
        <hr>
        <div class="row">
          <div class="col-sm-12">
            <h3>Commute Profiles</h3>
            <p>The data shown is from journey profiles generated by OpenTripPlanner's Profile Routing engine. The journeys are taken from the 2011 census commutes for the DC/VA/MD region which contains home/work locations by census block.</p>
            <p>Only commuters living in Arlington, or commuting to Arlington were used due to large size of the data set of the region.<p>
              <p>The profiles created used a few assumptions:</p>
              <ul>
                <li>A commute time between 6am and 9am</li>
                <li>Maximum walk time of 15 minutes</li>
                <li>Walk speed of ~3.2mph</li>
                <li>Bike speed of ~9.2mph</li>
              </ul>
              <p>The transit network comes from all availalbe GTFS feeds in the area. The road network to derive the biking options comes from OpenStreetMap.</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="//cdnjs.cloudflare.com/ajax/libs/spin.js/2.0.1/spin.min.js"></script>
    <script src="//api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-pip/v0.0.2/leaflet-pip.js'></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.13/d3.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/crossfilter/1.3.7/crossfilter.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/dc/1.6.0/dc.js"></script>
    <script src="http://d3js.org/colorbrewer.v1.min.js"></script>
    <script src="d3.hexbin.v0.min.js"></script>
    <script src="hexbin.js"></script>
    <script>
      // Spinner
      var spinner = new Spinner().spin(document.body);

      // constants
      var height = 150,
        width = 400,
        margin = {
          top: 0,
          right: 10,
          bottom: 20,
          left: 40
        };

      // globals
      var blocks, currentDimension, data, dimensions = {}, geoBounds, outerbounds,
        _id, json, originalJSON, map, options;

      // Checkboxes
      var $showBounds = document.getElementById('show-bounds');

      // Radio
      var $bikeAndWalk = document.getElementById('bike-and-walk');
      var $bikeOnly = document.getElementById('bike-only');
      var $carOnly = document.getElementById('car-only');

      // Max time
      var $colorscale = document.getElementById('color-scale');
      var $colorScaleLabel = document.getElementById('color-scale-label');
      var $impactChartLabel = document.getElementById('impact-chart-label');
      var $percentChart = document.getElementById('percent-chart');

      // Expose charts
      var charts = window.charts = {};

      // Current Color Brewer Scale
      var colorScale = colorbrewer.RdYlBu[4];

      // Load Bounds
      d3.json('data/bounds.geo.json', processGeoJson);

      function processGeoJson(err, j) {
        if (err) console.error(err);
        geoBounds = j;

        // Load json
        d3.csv('data/access-mode-diff.csv', function(d) {
          return {
            coords: [
              [ +d.flng, +d.flat ],
              [ +d.tlng, +d.tlat ]
            ],
            distance: haversine(+d.flat, +d.flng, +d.tlat, +d.tlng, true),
            trips: +d.trips,
            dbike: +d.dbike,
            dwalk: +d.dwalk,
            tbike: +d.tbike,
            tbikea: +d.tbikea,
            twalk: +d.twalk,
            twalka: +d.twalka,
            impact: 0,
            modes: 1 // All
          };
        }, processCsv);
      }

      function processCsv(err, j) {
        if (err) console.error(err);
        json = j;

        // Duplicate records based on # of trips
        var duplicates = [];
        json.forEach(function(r) {
          if (r.twalk === -1 && r.tbike === -1) {
            r.impact = r.dbike > 0 ? r.dbike : 0;
            r.modes = 3; // no bike or walk
          } else if (r.twalk === -1) {
            r.impact = r.tbikea;
            r.modes = 2; // no walk
          } else if (r.twalk > r.tbike) {
            r.impact = (r.twalk - r.tbike);
          }

          for (var i = 1; i < r.trips; i++) {
            var c = clone(r);
            delete c.trips;
            duplicates.push(clone(r));
          }
          delete r.trips;
        });
        json = json.concat(duplicates);

        // Filter out the outliers
        json = json.filter(function(d) {
          return d.modes > 1 || d.impact < 20;
        });

        // Show viz & stop spinner
        document.getElementById('viz').style.display = 'block';

        // After displaying, setup the map
        map = L.mapbox.map('map', 'conveyal.gepida3i', {
          touchZoom: false,
          scrollWheelZoom: false
        }).setView([38.8399874, -77.0911667], 11);

        // Add bounds
        geoBounds = L.geoJson(geoBounds, {
           style: {
             fillOpacity: 0
           }
        }).addTo(map);

        // Generate Hexbins
        map.on('viewreset', function() {
          generateHexbins(map, dimensions);
        });

        // Crossfilterize
        processJson(json, map);

        // Show extends
        d3.json('data/outerbounds.geo.json', function(err, json) {
          outerbounds = L.geoJson(json, {
            style: {
              fillOpacity: 0
            }
          }).addTo(map)
        });
      }

      function processJson(json, map) {
        // Dispose of all dimensions
        for (var d in dimensions) dimensions[d].dispose();

        // Remove all current data
        if (options) options.remove();

        // Create the crossfilter instance
        options = crossfilter(json);

        // Create the dimensions
        dimensions = getDimensions(options);
        currentDimension = dimensions.distance;

        charts.distance = dc.lineChart('#distance-chart')
          .height(height)
          .width(width)
          .margins(margin)
          .x(d3.scale.linear().domain([0, 40]))
          .elasticY(true)
          .round(Math.round)
          .dimension(dimensions.distance)
          .group(dimensions.distance.group(function(d) {
            return Math.round(d);
          }));

        charts.impact = dc.barChart('#impact-chart')
          .height(height)
          .width(width)
          .margins(margin)
          .round(Math.round)
          .elasticY(true)
          .x(d3.scale.linear().domain([1, 15]))
          .dimension(dimensions.impact)
          .group(dimensions.impact.group(function(d) {
            return Math.round(d);
          }));

        charts.percent = dc.barChart('#percent-chart')
          .height(height)
          .width(width)
          .margins(margin)
          .round(Math.round)
          .elasticY(true)
          .elasticX(true)
          .x(d3.scale.linear().domain([0, 100]))
          .dimension(dimensions.percent)
          .group(dimensions.percent.group(function(d) {
            return Math.round(d);
          }));

        charts.count = dc.dataCount('#data-count')
          .dimension(options)
          .group(options.groupAll());

        dimensions.modes.filter(function(d) {
          return d === 1;
        });

        dc.renderAll();

        charts.distance.on('filtered', function() {
          currentDimension = dimensions.distance;
        });
        charts.impact.on('filtered', function() {
          currentDimension = dimensions.impact;
        });

        // Attach to dc.js renderLet
        charts.distance.renderlet(function(c) {
          dc.events.trigger(function() {
            // Rendering allll
            console.log('DC Events triggered');

            // Redraw the hexbins
            generateHexbins(map);

            // Stop spinner
            spinner.stop();
          });
        });

        $bikeAndWalk.onclick = function() {
          $bikeAndWalk.classList.add('active');
          $bikeOnly.classList.remove('active');
          $carOnly.classList.remove('active');

          colorScale = colorbrewer.RdYlBu[4];

          dc.filterAll();
          charts.impact = dc.barChart('#impact-chart')
            .height(height)
            .width(width)
            .margins(margin)
            .round(Math.round)
            .elasticY(true)
            .x(d3.scale.linear().domain([1, 15]))
            .dimension(dimensions.impact)
            .group(dimensions.impact.group(function(d) {
              return Math.round(d);
            }));

          dimensions.modes.filter(function(d) {
            return d === 1;
          });
          $colorScaleLabel.textContent = 'Impact';
          $impactChartLabel.textContent = 'Impact (Walk time - Bike time)';
          $percentChart.style.display = 'block';
          dc.renderAll();
        };

        $bikeOnly.onclick = function() {
          $bikeAndWalk.classList.remove('active');
          $bikeOnly.classList.add('active');
          $carOnly.classList.remove('active');

          colorScale = colorbrewer.RdYlGn[4].reverse();

          dc.filterAll();
          charts.impact = dc.barChart('#impact-chart')
            .height(height)
            .width(width)
            .margins(margin)
            .round(Math.round)
            .elasticY(true)
            .x(d3.scale.linear().domain([1, 25]))
            .dimension(dimensions.impact)
            .group(dimensions.impact.group(function(d) {
              return Math.round(d);
            }));

          dimensions.modes.filter(function(d) {
            return d === 2;
          });
          $colorScaleLabel.textContent = 'Bike Time';
          $impactChartLabel.textContent = 'Total Bike Time';
          $percentChart.style.display = 'block';

          dc.renderAll();
        };

        $carOnly.onclick = function() {
          $bikeAndWalk.classList.remove('active');
          $bikeOnly.classList.remove('active');
          $carOnly.classList.add('active');

          colorScale = colorbrewer.RdYlGn[3].reverse();
          colorScale.unshift('#333');

          dc.filterAll();
          charts.impact = dc.barChart('#impact-chart')
            .height(height)
            .width(width)
            .margins(margin)
            .round(Math.round)
            .elasticY(true)
            .x(d3.scale.linear().domain([1, 95]))
            .dimension(dimensions.impact)
            .group(dimensions.impact.group(function(d) {
              return Math.round(d);
            }));

          dimensions.modes.filter(function(d) {
            return d === 3;
          });
          $colorScaleLabel.textContent = 'Bike Time';
          $impactChartLabel.textContent = 'Bike Time';
          $percentChart.style.display = 'none';
          dc.renderAll();
        };

        $showBounds.onchange = function() {
          var style = {
            opacity: $showBounds.checked ? 0.5 : 0
          };
          geoBounds.setStyle(style);
          outerbounds.setStyle(style);
        };
      }

      function getDimensions(o) {
        return {
          distance: o.dimension(function(d) {
            return d.distance;
          }),
          impact: o.dimension(function(d) {
            return d.impact;
          }),
          /*destination: o.dimension(function(d) {
            return d.coords[1];
          }),*/
          modes: o.dimension(function(d) {
            return d.modes;
          }),
          percent: o.dimension(function(d) {
            if (d.tbike === -1) return 0;
            return (d.tbikea / d.tbike) * 100;
          })
        };
      }

      var _polygons = [];
      var _polylines = [];

      function generateHexbins(map) {
        _polylines.forEach(map.removeLayer.bind(map));
        _polygons.forEach(map.removeLayer.bind(map));

        var bounds = map.getBounds();
        var $map = document.getElementById('map');
        var rmax = (bounds.getNorth() - bounds.getSouth()) / 45;

        // Allllll
        var data = currentDimension.top(Infinity);

        // Generate hexbins
        var origins = data.map(function(d) {
          var j = d.coords[0];
          j.impact = d.impact;
          j.destination = d.coords[1];
          return j;
        });

        var cscale = null;
        var hexbins = hexbin(origins, {
          caccessor: function(b) {
            return b.impact;
          },
          cscale: function(bs) {
            var min = Infinity;
            var max = -Infinity;
            bs.forEach(function(b) {
              b.impact = b.reduce(function(v, j) {
                return v + j.impact;
              }, 0);
              b.impact = b.impact / b.length;
              if (b.impact < min) min = b.impact;
              if (b.impact > max) max = b.impact;
            });

            $colorscale.innerHTML = null;

            var impacts = bs.map(function(d) { return d.impact; });
            impacts.sort(d3.ascending);

            var quantile = 2 / 3;
            var upper = d3.quantile(impacts, quantile);
            while (upper === 0) {
              quantile += 0.05;
              upper = d3.quantile(impacts, quantile);
            }

            console.log(min, upper, max);
            cscale = d3.scale.linear()
              .domain([ min, upper / 2, upper, max ])
              .range(colorScale);

            var scales = '';

            for (var i = 0; i <= 5; i++) {
              var q = d3.quantile(impacts, i / 5);
              scales += '<span class="color-scale-block" style="background-color:' + cscale(q) + ';">' + q.toFixed(1) + '</span>';
            }

            $colorscale.innerHTML = scales;

            return cscale;

          },
          height: $map.clientHeight,
          rmax: rmax,
          width: $map.clientWidth
        });

        _polygons = hexbins.map(function(d) {
          var center = [ d.center[1], d.center[0] ];
          return L.polygon(d.coords, {
            stroke: true,
            weight: 1,
            color: '#e5e5e5',
            fill: true,
            fillOpacity: 0.75,
            fillColor: d.color
          }).addTo(map)
            .on('click', function() {
              _polylines.forEach(map.removeLayer.bind(map));
              _polylines = d.bin.map(function(bin) {
                var destination = bin.destination;
                return L.polyline([ center, [ destination[1], destination[0] ] ], {
                  color: cscale(bin.impact),
                  weight: 3
                }).addTo(map);
              });
            })
            .bindPopup(d.bin.length + ' commute(s) from this bin.');
        });
      }

      function filterDestinations(inBound, outBound, dimension, bounds) {
        if (inBound && outBound) {
          dimension.filterAll();
        } else if (inBound) {
          dimension.filter(function(c) {
            return pip(c, bounds);
          });
        } else if (outBound) {
          dimension.filter(function(c) {
            return !pip(c, bounds);
          });
        } else {
          dimension.filter(function(c) {
            return false;
          });
        }

        dc.renderAll();
      }

      function pip(ll, bounds) {
        var layer = leafletPip.pointInLayer(ll, bounds, true);
        if (layer.length) return true;
        else return false;
      }

      function clone(obj) {
        if (obj === null || typeof(obj) != 'object')
          return obj;

        var temp = obj.constructor();
        for (var key in obj) temp[key] = clone(obj[key]);
        return temp;
      }

      /**
       * Get the haversine distance between two points
       *
       * @param {Number} starting latitude
       * @param {Number} starting longitude
       * @param {Number} ending latitude
       * @param {Number} ending longitude
       * @param {Boolean} return the distance in miles instead of kilometers
       * @returns {Number} distance between the points
       */

      function haversine(lat1, lon1, lat2, lon2, miles) {
        var R = miles ? 3960 : 6371;

        var dLat = rad(lat2 - lat1);
        var dLon = rad(lon2 - lon1);

        lat1 = rad(lat1);
        lat2 = rad(lat2);

        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
      };

      /**
       * Convert a lat/lon point to radians
       *
       * @param {Number} n
       * @returns {Number} r
       */

      function rad(n) {
        return n * Math.PI / 180;
      }
    </script>
  </body>
</html>